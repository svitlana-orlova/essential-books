<!doctype html>
<html lang="en">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="../../assets/main.css" rel="stylesheet">
</head>
<body class="page">
<header class="page__header">
    <div class="page__header__left">
        <a id="link-home" href="../../index.html">
            &nbsp;Essential Books</a>
    </div>
</header>
<div class="content">
    <div class="article">
      

<div style="display: flex; justify-content: space-between">
  <h1 class="title">Type erasing type erasure with std::any</h1>
  <a class="edit-link" style="font-size: 80%" href="https://notion.so/252ece15c398409eb9fc941fe3f57da5" rel="nofollow" target="_blank">suggest change</a>
</div>


      
<p>This example uses C++14 and <code>boost::any</code>. In C++17 you can swap in <code>std::any</code> instead.
</p>
<p>The syntax we end up with is:
</p>

<div class="code-box lang-Plain Text">
	<div>
	<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl">const auto print =
</span></span><span class="line"><span class="cl">  make_any_method&lt;void(std::ostream&amp;)&gt;([](auto&amp;&amp; p, std::ostream&amp; t){ t &lt;&lt; p &lt;&lt; "\n"; });
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">super_any&lt;decltype(print)&gt; a = 7;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">(a-&gt;*print)(std::cout);</span></span></code></pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>
<p>which is almost optimal.
</p>
<p>This example is based off of work by [@dyp](http://coliru.stacked-crooked.com/a/2ab8d7e41d24e616) and [@cpplearner](http://stackoverflow.com/a/38865269/1774667) as well as my own.
</p>
<hr id="f87e7dcc-1b70-411b-8a71-d27798a10bcc">
<p>First we use a tag to pass around types:
</p>

<div class="code-box lang-Plain Text">
	<div>
	<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl">template&lt;class T&gt;struct tag_t{constexpr tag_t(){};};
</span></span><span class="line"><span class="cl">template&lt;class T&gt;constexpr tag_t&lt;T&gt; tag{};</span></span></code></pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>
<p>This trait class gets the signature stored with an <code>any_method</code>:
</p>
<p>This creates a function pointer type, and a factory for said function pointers, given an <code>any_method</code>:
</p>

<div class="code-box lang-Plain Text">
	<div>
	<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl">template&lt;class any_method&gt;
</span></span><span class="line"><span class="cl">using any_sig_from_method = typename any_method::signature;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">template&lt;class any_method, class Sig=any_sig_from_method&lt;any_method&gt;&gt;
</span></span><span class="line"><span class="cl">struct any_method_function;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">template&lt;class any_method, class R, class...Args&gt;
</span></span><span class="line"><span class="cl">struct any_method_function&lt;any_method, R(Args...)&gt;
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  template&lt;class T&gt;
</span></span><span class="line"><span class="cl">  using decorate = std::conditional_t&lt; any_method::is_const, T const, T &gt;;
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  using any = decorate&lt;boost::any&gt;;
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  using type = R(*)(any&amp;, any_method const*, Args&amp;&amp;...);
</span></span><span class="line"><span class="cl">  template&lt;class T&gt;
</span></span><span class="line"><span class="cl">  type operator()( tag_t&lt;T&gt; )const{
</span></span><span class="line"><span class="cl">    return +[](any&amp; self, any_method const* method, Args&amp;&amp;...args) {
</span></span><span class="line"><span class="cl">      return (*method)( boost::any_cast&lt;decorate&lt;T&gt;&amp;&gt;(self), decltype(args)(args)... );
</span></span><span class="line"><span class="cl">    };
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">};</span></span></code></pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>
<p><code>any_method_function::type</code> is the type of a function pointer we will store alongside the instance. <code>any_method_function::operator()</code> takes a <code>tag_t&lt;T&gt;</code> and writes a custom instance of the <code>any_method_function::type</code> that assumes the <code>any&amp;</code> is going to be a <code>T</code>.
</p>
<p>We want to be able to type-erase more than one method at a time. So we bundle them up in a tuple, and write a helper wrapper to stick the tuple into static storage on a per-type basis and maintain a pointer to them.
</p>

<div class="code-box lang-Plain Text">
	<div>
	<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl">template&lt;class...any_methods&gt;
</span></span><span class="line"><span class="cl">using any_method_tuple = std::tuple&lt; typename any_method_function&lt;any_methods&gt;::type... &gt;;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">template&lt;class...any_methods, class T&gt;
</span></span><span class="line"><span class="cl">any_method_tuple&lt;any_methods...&gt; make_vtable( tag_t&lt;T&gt; ) {
</span></span><span class="line"><span class="cl">  return std::make_tuple(
</span></span><span class="line"><span class="cl">    any_method_function&lt;any_methods&gt;{}(tag&lt;T&gt;)...
</span></span><span class="line"><span class="cl">  );
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">template&lt;class...methods&gt;
</span></span><span class="line"><span class="cl">struct any_methods {
</span></span><span class="line"><span class="cl">private:
</span></span><span class="line"><span class="cl">  any_method_tuple&lt;methods...&gt; const* vtable = 0;
</span></span><span class="line"><span class="cl">  template&lt;class T&gt;
</span></span><span class="line"><span class="cl">  static any_method_tuple&lt;methods...&gt; const* get_vtable( tag_t&lt;T&gt; ) {
</span></span><span class="line"><span class="cl">    static const auto table = make_vtable&lt;methods...&gt;(tag&lt;T&gt;);
</span></span><span class="line"><span class="cl">    return &amp;table;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">public:
</span></span><span class="line"><span class="cl">  any_methods() = default;
</span></span><span class="line"><span class="cl">  template&lt;class T&gt;
</span></span><span class="line"><span class="cl">  any_methods( tag_t&lt;T&gt; ): vtable(get_vtable(tag&lt;T&gt;)) {}
</span></span><span class="line"><span class="cl">  any_methods&amp; operator=(any_methods const&amp;)=default;
</span></span><span class="line"><span class="cl">  template&lt;class T&gt;
</span></span><span class="line"><span class="cl">  void change_type( tag_t&lt;T&gt; ={} ) { vtable = get_vtable(tag&lt;T&gt;); }
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">  template&lt;class any_method&gt;
</span></span><span class="line"><span class="cl">  auto get_invoker( tag_t&lt;any_method&gt; ={} ) const {
</span></span><span class="line"><span class="cl">    return std::get&lt;typename any_method_function&lt;any_method&gt;::type&gt;( *vtable );
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">};</span></span></code></pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>
<p>We could specialize this for a cases where the vtable is small (for example, 1 item), and use direct pointers stored in-class in those cases for efficiency.
</p>
<p>Now we start the <code>super_any</code>. I use <code>super_any_t</code> to make the declaration of <code>super_any</code> a bit easier.
</p>

<div class="code-box lang-Plain Text">
	<div>
	<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl">template&lt;class...methods&gt;
</span></span><span class="line"><span class="cl">struct super_any_t;</span></span></code></pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>
<p>This searches the methods that the super any supports for SFINAE and better error messages:
</p>

<div class="code-box lang-Plain Text">
	<div>
	<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl">template&lt;class super_any, class method&gt;
</span></span><span class="line"><span class="cl">struct super_method_applies_helper : std::false_type {};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">template&lt;class M0, class...Methods, class method&gt;
</span></span><span class="line"><span class="cl">struct super_method_applies_helper&lt;super_any_t&lt;M0, Methods...&gt;, method&gt; :
</span></span><span class="line"><span class="cl">    std::integral_constant&lt;bool, std::is_same&lt;M0, method&gt;{}  || super_method_applies_helper&lt;super_any_t&lt;Methods...&gt;, method&gt;{}&gt;
</span></span><span class="line"><span class="cl">{};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">template&lt;class...methods, class method&gt;
</span></span><span class="line"><span class="cl">auto super_method_test( super_any_t&lt;methods...&gt; const&amp;, tag_t&lt;method&gt; )
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  return std::integral_constant&lt;bool, super_method_applies_helper&lt; super_any_t&lt;methods...&gt;, method &gt;{} &amp;&amp; method::is_const &gt;{};
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">template&lt;class...methods, class method&gt;
</span></span><span class="line"><span class="cl">auto super_method_test( super_any_t&lt;methods...&gt;&amp;, tag_t&lt;method&gt; )
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  return std::integral_constant&lt;bool, super_method_applies_helper&lt; super_any_t&lt;methods...&gt;, method &gt;{} &gt;{};
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">template&lt;class super_any, class method&gt;
</span></span><span class="line"><span class="cl">struct super_method_applies:
</span></span><span class="line"><span class="cl">    decltype( super_method_test( std::declval&lt;super_any&gt;(), tag&lt;method&gt; ) )
</span></span><span class="line"><span class="cl">{};</span></span></code></pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>
<p>Next we create the <code>any_method</code> type. An <code>any_method</code> is a pseudo-method-pointer. We create it globally and <code>const</code>ly using syntax like:
</p>

<div class="code-box lang-Plain Text">
	<div>
	<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl">const auto print=make_any_method( [](auto&amp;&amp;self, auto&amp;&amp;os){ os &lt;&lt; self; } );</span></span></code></pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>
<p>or in C++17:
</p>

<div class="code-box lang-Plain Text">
	<div>
	<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl">const any_method print=[](auto&amp;&amp;self, auto&amp;&amp;os){ os &lt;&lt; self; };</span></span></code></pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>
<p>Note that using a non-lambda can make things hairy, as we use the type for a lookup step. This can be fixed, but would make this example longer than it already is. So always initialize an any method from a lambda, or from a type parametarized on a lambda.
</p>

<div class="code-box lang-Plain Text">
	<div>
	<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl">template&lt;class Sig, bool const_method, class F&gt;
</span></span><span class="line"><span class="cl">struct any_method {
</span></span><span class="line"><span class="cl">  using signature=Sig;
</span></span><span class="line"><span class="cl">  enum{is_const=const_method};
</span></span><span class="line"><span class="cl">private:
</span></span><span class="line"><span class="cl">  F f;
</span></span><span class="line"><span class="cl">public:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  template&lt;class Any,
</span></span><span class="line"><span class="cl">    // SFINAE testing that one of the Anys's matches this type:
</span></span><span class="line"><span class="cl">    std::enable_if_t&lt; super_method_applies&lt; Any&amp;&amp;, any_method &gt;{}, int&gt;* =nullptr
</span></span><span class="line"><span class="cl">  &gt;
</span></span><span class="line"><span class="cl">  friend auto operator-&gt;*( Any&amp;&amp; self, any_method const&amp; m ) {
</span></span><span class="line"><span class="cl">    // we don't use the value of the any_method, because each any_method has
</span></span><span class="line"><span class="cl">    // a unique type (!) and we check that one of the auto*'s in the super_any
</span></span><span class="line"><span class="cl">    // already has a pointer to us.  We then dispatch to the corresponding
</span></span><span class="line"><span class="cl">    // any_method_data...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return [&amp;self, invoke = self.get_invoker(tag&lt;any_method&gt;), m](auto&amp;&amp;...args)-&gt;decltype(auto)
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">      return invoke( decltype(self)(self), &amp;m, decltype(args)(args)... );
</span></span><span class="line"><span class="cl">    };
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  any_method( F fin ):f(std::move(fin)) {}
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  template&lt;class...Args&gt;
</span></span><span class="line"><span class="cl">  decltype(auto) operator()(Args&amp;&amp;...args)const {
</span></span><span class="line"><span class="cl">    return f(std::forward&lt;Args&gt;(args)...);
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">};</span></span></code></pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>
<p>A factory method, not needed in C++17 I believe:
</p>

<div class="code-box lang-Plain Text">
	<div>
	<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl">template&lt;class Sig, bool is_const=false, class F&gt;
</span></span><span class="line"><span class="cl">any_method&lt;Sig, is_const, std::decay_t&lt;F&gt;&gt;
</span></span><span class="line"><span class="cl">make_any_method( F&amp;&amp; f ) {
</span></span><span class="line"><span class="cl">  return {std::forward&lt;F&gt;(f)};
</span></span><span class="line"><span class="cl">}</span></span></code></pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>
<p>This is the augmented <code>any</code>. It is both an <code>any</code>, and it carries around a bundle of type-erasure function pointers that change whenever the contained <code>any</code> does:
</p>

<div class="code-box lang-Plain Text">
	<div>
	<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl">template&lt;class... methods&gt;
</span></span><span class="line"><span class="cl">struct super_any_t:boost::any, any_methods&lt;methods...&gt; {
</span></span><span class="line"><span class="cl">  using vtable=any_methods&lt;methods...&gt;;
</span></span><span class="line"><span class="cl">public:
</span></span><span class="line"><span class="cl">  template&lt;class T,
</span></span><span class="line"><span class="cl">    std::enable_if_t&lt; !std::is_base_of&lt;super_any_t, std::decay_t&lt;T&gt;&gt;{}, int&gt; =0
</span></span><span class="line"><span class="cl">  &gt;
</span></span><span class="line"><span class="cl">  super_any_t( T&amp;&amp; t ):
</span></span><span class="line"><span class="cl">    boost::any( std::forward&lt;T&gt;(t) )
</span></span><span class="line"><span class="cl">  {
</span></span><span class="line"><span class="cl">    using dT=std::decay_t&lt;T&gt;;
</span></span><span class="line"><span class="cl">    this-&gt;change_type( tag&lt;dT&gt; );
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  boost::any&amp; as_any()&amp;{return *this;}
</span></span><span class="line"><span class="cl">  boost::any&amp;&amp; as_any()&amp;&amp;{return std::move(*this);}
</span></span><span class="line"><span class="cl">  boost::any const&amp; as_any()const&amp;{return *this;}
</span></span><span class="line"><span class="cl">  super_any_t()=default;
</span></span><span class="line"><span class="cl">  super_any_t(super_any_t&amp;&amp; o):
</span></span><span class="line"><span class="cl">    boost::any( std::move( o.as_any() ) ),
</span></span><span class="line"><span class="cl">    vtable(o)
</span></span><span class="line"><span class="cl">  {}
</span></span><span class="line"><span class="cl">  super_any_t(super_any_t const&amp; o):
</span></span><span class="line"><span class="cl">    boost::any( o.as_any() ),
</span></span><span class="line"><span class="cl">    vtable(o)
</span></span><span class="line"><span class="cl">  {}
</span></span><span class="line"><span class="cl">  template&lt;class S,
</span></span><span class="line"><span class="cl">    std::enable_if_t&lt; std::is_same&lt;std::decay_t&lt;S&gt;, super_any_t&gt;{}, int&gt; =0
</span></span><span class="line"><span class="cl">  &gt;
</span></span><span class="line"><span class="cl">  super_any_t( S&amp;&amp; o ):
</span></span><span class="line"><span class="cl">    boost::any( std::forward&lt;S&gt;(o).as_any() ),
</span></span><span class="line"><span class="cl">    vtable(o)
</span></span><span class="line"><span class="cl">  {}
</span></span><span class="line"><span class="cl">  super_any_t&amp; operator=(super_any_t&amp;&amp;)=default;
</span></span><span class="line"><span class="cl">  super_any_t&amp; operator=(super_any_t const&amp;)=default;
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  template&lt;class T,
</span></span><span class="line"><span class="cl">    std::enable_if_t&lt; !std::is_same&lt;std::decay_t&lt;T&gt;, super_any_t&gt;{}, int&gt;* =nullptr
</span></span><span class="line"><span class="cl">  &gt;
</span></span><span class="line"><span class="cl">  super_any_t&amp; operator=( T&amp;&amp; t ) {
</span></span><span class="line"><span class="cl">    ((boost::any&amp;)*this) = std::forward&lt;T&gt;(t);
</span></span><span class="line"><span class="cl">    using dT=std::decay_t&lt;T&gt;;
</span></span><span class="line"><span class="cl">    this-&gt;change_type( tag&lt;dT&gt; );
</span></span><span class="line"><span class="cl">    return *this;
</span></span><span class="line"><span class="cl">  }  
</span></span><span class="line"><span class="cl">};</span></span></code></pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>
<p>Because we store the <code>any_method</code>s as <code>const</code> objects, this makes making a <code>super_any</code> a bit easier:
</p>

<div class="code-box lang-Plain Text">
	<div>
	<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl">template&lt;class...Ts&gt;
</span></span><span class="line"><span class="cl">using super_any = super_any_t&lt; std::remove_cv_t&lt;Ts&gt;... &gt;;</span></span></code></pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>
<p>Test code:
</p>

<div class="code-box lang-Plain Text">
	<div>
	<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl">const auto print = make_any_method&lt;void(std::ostream&amp;)&gt;([](auto&amp;&amp; p, std::ostream&amp; t){ t &lt;&lt; p &lt;&lt; "\n"; });
</span></span><span class="line"><span class="cl">const auto wprint = make_any_method&lt;void(std::wostream&amp;)&gt;([](auto&amp;&amp; p, std::wostream&amp; os ){ os &lt;&lt; p &lt;&lt; L"\n"; });
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  super_any&lt;decltype(print), decltype(wprint)&gt; a = 7;
</span></span><span class="line"><span class="cl">  super_any&lt;decltype(print), decltype(wprint)&gt; a2 = 7;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  (a-&gt;*print)(std::cout);
</span></span><span class="line"><span class="cl">  (a-&gt;*wprint)(std::wcout);
</span></span><span class="line"><span class="cl">}</span></span></code></pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>
<p><a href="http://coliru.stacked-crooked.com/a/fbd10edb3336cce1">live example</a>.
</p>
<p>Originally posted <a href="http://stackoverflow.com/a/38837687/1774667">here</a> in a SO self question &amp; answer (and people noted above helped with the implementation).
</p>

      <div class="forum-link">
  Found a mistake? Have a question or improvement idea?
  <a href="type-erasing-type-erasure-with-stdany-252ece15c398409eb9fc941fe3f57da5.html#" onclick="showContact(); return false;">Let me know</a>.
</div>

      <form id="contact-form" action="https://formsubmit.co/kkowalczyk@gmail.com" method="POST">
  <p>
    </p><div class="contact-light">Feedback about page:</div>
    <input type="text" name="page-url" id="contact-page-url" readonly>
  

  <p>
    </p><div class="contact-light">Feedback:</div>
    <textarea name="message" id="msg-for-chris"></textarea>
    <div class="contact-light">Optional: your email if you want me to get back to you: </div>
    <input type="email" name="email">
    <input type="hidden" name="_template" value="box">
    <input type="text" name="_honey" class="noshow">
  

  <p>
    <button type="submit" class="contact-btn">
      Send Feedback
    </button>

    <button class="contact-btn" style="float: right;" onclick="hideContact(); return false;">
      Cancel
    </button>
  </p>
</form>


      <hr class="article-bottom-sep">
    </div>

    <div id="page-toc"><div class="article chapter-toc svelte-1t851gm"><div class="mtoc-0 svelte-1t851gm"><b>Type erasure:</b></div><div class="mtoc-1 svelte-1t851gm"><span class="no svelte-1ib47n1">*</span><a href="type-erasure-263bdee280d54aa583eb2ea074356d3d.html">Type Erasure</a></div><div class="mtoc-1 svelte-1t851gm"><span class="no svelte-1ib47n1">*</span><a href="a-move-only-stdfunction-c119ce9ec36b4e96add10ea403079f69.html">A move-only std::function</a></div><div class="mtoc-1 svelte-1t851gm"><span class="no svelte-1ib47n1">*</span><a href="erasing-down-to-a-regular-type-with-manual-vtable-f7560e8bf87b484a8cf51d6e1d46b6f8.html">Erasing down to a regular type with manual vtable</a></div><div class="mtoc-1 svelte-1t851gm"><span class="no svelte-1ib47n1">*</span><a href="basic-mechanism-12da516808d44eb9b74e49dc625858ff.html">Basic mechanism</a></div><div class="mtoc-1 svelte-1t851gm"><span class="no svelte-1ib47n1">*</span><a href="erasing-down-to-a-contiguous-buffer-of-t-64b023be245245b28d7530e946a3e525.html">Erasing down to a contiguous buffer of T</a></div><div class="mtoc-1 svelte-1t851gm"><span class="no svelte-1ib47n1">*</span><b>Type erasing type erasure with std::any</b></div></div></div>

    <div id="chapter-toc-wrapper">
      <hr>
      <div class="hdr">Table Of Contents</div>
      <div id="book-toc"><div class="article toc svelte-1ib47n1"><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">0</span><a href="getting-started-069713c9355d43e5bbe3fe65ccc5d89f.html">Getting started</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">1</span><a href="literals-f6fb0c70b2a7438e8fd0214354d4363c.html">Literals</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">2</span><a href="basic-type-keywords-cad79b8f8e224786b5223ce3f7989dfb.html">Basic type keywords</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">3</span><a href="operator-precedence-9582f39a18d44387a429d2d9d9c1c0a3.html">Operator precedence</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">4</span><a href="floating-point-arithmetic-4e7523ec807e469b846d6f0e98a9f133.html">Floating point arithmetic</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">5</span><a href="bit-operators-c48a63c8822c4a23a96060de4face6ae.html">Bit operators</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">6</span><a href="bit-manipulation-99e194305cdd423f8fa90e2f0bf264ab.html">Bit manipulation</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">7</span><a href="bit-fields-ea4c768f8ffd48a6bc20bd19b214545c.html">Bit fields</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">8</span><a href="arrays-3724ad56a87948bf847e5adcfcb60c18.html">Arrays</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">9</span><a href="flow-control-52470773ddd64b1bad397b26f7b28f00.html">Flow control</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">10</span><a href="const-keyword-6fdcfacef4394f7387ef255a8f378573.html">const keyword</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">11</span><a href="loops-ee10cf4584c7467c8068ea9076a2401a.html">Loops</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">12</span><a href="mutable-keyword-4dc216075d044a95bcedba855fbfa11f.html">mutable keyword</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">13</span><a href="friend-keyword-546689ba7cc049cbae9405172f20d6dc.html">friend keyword</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">14</span><a href="keywords-193b149e733b4344889829dc4a2ef0b0.html">keywords</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">15</span><a href="variable-declaration-keywords-7b3003e0533146e9a21603a87845d9e4.html">Variable declaration keywords</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">16</span><a href="auto-keyword-fe5135d20f284675bccd611b7222102a.html">auto keyword</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">17</span><a href="pointers-a47adf4df2bb4f7284ee798641440dfd.html">Pointers</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">18</span><a href="type-keywords-class-enum-struct-union-903c7a47fbc04b1281a4646b290a4e1e.html">Type keywords (class, enum, struct, union)</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">19</span><a href="classes-structs-40e8450d47364ad0be7da2d9307ddf4f.html">Classes / structs</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">20</span><a href="stdstring-b886ff5d614b4aa99e99851b7998439b.html">std::string</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">21</span><a href="enumeration-89d591b25143487b8a09144b6b266e4c.html">Enumeration</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">22</span><a href="stdatomict-ede1fd1200134e8ba92d109c2ef39c10.html">std::atomic<T></a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">23</span><a href="stdvector-8655f4929c514f68ad528b6c1e02a277.html">std::vector</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">24</span><a href="stdarray-f2a0f00868d44ef0b159b4601056dc66.html">std::array</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">25</span><a href="stdpair-db03800f1091419fbb8be6357b79b0ee.html">std::pair</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">26</span><a href="stdmap-50a27510120b4da09ecbcf15396a0108.html">std::map</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">27</span><a href="stdunordered_map-bd95f7bc834a4faf992f446d54f5fc91.html">std::unordered_map</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">28</span><a href="stdset-and-stdmultiset-0789dc5502104292957ded83df8e73af.html">std::set and std::multiset</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">29</span><a href="stdany-d5d40e50c2344e348c366916f8e79960.html">std::any</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">30</span><a href="stdvariant-5644241eceec479a8322e9c1780f1515.html">std::variant</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">31</span><a href="stdoptional-de2aa703c2f64f94bc50eb5201c26ac3.html">std::optional</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">32</span><a href="stdinteger_sequence-333099ca9ef14569b9ada7a9275c368b.html">std::integer_sequence</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">33</span><a href="stdfunction-263edcef95ee480a8c671e74662a250a.html">std::function</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">34</span><a href="stdforward_list-9a81e0e2994e41b0aa0f0bb41311ad7d.html">std::forward_list</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">35</span><a href="stdiomanip-1146c4bd8317421db231ebcb0eff5721.html">std::iomanip</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">36</span><a href="iterators-ee86edbe8dd9497aa24cfa516272404e.html">Iterators</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">37</span><a href="basic-io-13fedea6df65499692809cedb29d5f94.html">Basic I/O</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">38</span><a href="file-io-b96c747c3d8749a0b2bb264f7c11b216.html">File I/O</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">39</span><a href="streams-2457e2b52a2a44899eacadb5cebfd9b8.html">Streams</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">40</span><a href="stream-manipulators-ecf8cc46eac44c36a422ed2cca054451.html">Stream manipulators</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">41</span><a href="metaprogramming-cbd900b316844f0d977a5a5b2a20aff3.html">Metaprogramming</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">42</span><a href="returning-multiple-values-from-a-function-26e69b2d1c6d47eaaf8747fa9cfbdf56.html">Returning multiple values from a function</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">43</span><a href="references-cb822004fe614bd891b8d45b2acf0576.html">References</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">44</span><a href="polymorphism-efdc4616d5e44dceb49c941c07a9ac4b.html">Polymorphism</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">45</span><a href="value-and-reference-semantics-43b2d3b6c6aa4441b6653932542c711c.html">Value and reference semantics</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">46</span><a href="function-call-by-value-vs.-by-reference-6980d61af1fa491f8409409e295a4b03.html">Function call by value vs. by reference</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">47</span><a href="copying-vs-assignment-e197edf179134c71bf9f78feec182413.html">Copying vs assignment</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">48</span><a href="pointers-to-class-struct-members-a3104ba49a8b4f2aad8925f36d3b9595.html">Pointers to class / struct members</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">49</span><a href="the-this-pointer-c0487639ff5b4e90a0b39fe411676c2c.html">The this pointer</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">50</span><a href="smart-pointers-402ef4daa4e34503ab089a4aa56821b5.html">Smart pointers</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">51</span><a href="unions-3b939fe5bf07416eb6269b4dcfb5abc4.html">Unions</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">52</span><a href="templates-94bfa8684e024b90841b817c34132524.html">Templates</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">53</span><a href="namespaces-8a2953833e9542dcb126f5d5d4d9927a.html">Namespaces</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">54</span><a href="function-overloading-3b14aac520b34de09a04adc1cc273aec.html">Function overloading</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">55</span><a href="operator-overloading-2be9c7d5be12439a8968ad057c67187a.html">Operator overloading</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">56</span><a href="lambdas-715173900244456d87c482c582ca8abf.html">Lambdas</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">57</span><a href="threading-f1b860dbbe5a41eda67bb7b0181ec59f.html">Threading</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">58</span><a href="value-categories-d548e85641b849c8a801044c518c9fe5.html">Value categories</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">59</span><a href="preprocessor-83f01298280445998deb99728a5d557a.html">Preprocessor</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">60</span><a href="sfinae-0b17f7b911d14229931e966fb51d1ba9.html">SFINAE</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">61</span><a href="rule-of-three-five-and-zero-eb50f34fbfa84e169ad9d114eb1d34d9.html">Rule of three, five and zero</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">62</span><a href="raii-96325b08db024f4fa7a37510a746dbe2.html">RAII</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">63</span><a href="exceptions-5a1044bbeec647e0932c1a000fc67e20.html">Exceptions</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">64</span><a href="implementation-defined-behavior-48a240ac2fc84208bd3982f2c3d27cb4.html">Implementation-defined behavior</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">65</span><a href="special-member-functions-2ed71a30e22047b0b0e71bc14fce30c0.html">Special member functions</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">66</span><a href="random-numbers-ea515dbf689d48fbbfb893f8853d7ec0.html">Random numbers</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">67</span><a href="sorting-899c3027a75e4a44914410a53c6a2c11.html">Sorting</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">68</span><a href="regular-expressions-e1dd94aeaa5a4f89b959f2ec61771796.html">Regular expressions</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">69</span><a href="perfect-forwarding-fcd2d991afe04c4fa9fe760a139ae1f3.html">Perfect forwarding</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">70</span><a href="virtual-member-functions-d0bc06f8edea49a0bdbbc1bef0d073bd.html">Virtual member functions</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">71</span><a href="undefined-behavior-6c5aa9dd76984690bd9e644763376917.html">Undefined behavior</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">72</span><a href="overload-resolution-5fbdea23a3bd48e39bb9c7ca69fd9aa2.html">Overload resolution</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">73</span><a href="move-semantics-44b9891cfe654aa68ac6b623709b7c02.html">Move semantics</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">74</span><a href="pimpl-idiom-904db18bf9e44135accd8cab1b7efd09.html">Pimpl idiom</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">75</span><a href="copy-elision-a29d7b5a398943f18efa86ef82101f43.html">Copy elision</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">76</span><a href="fold-expressions-c477f25f108c44a488a07be0b1a8f442.html">Fold expressions</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">77</span><a href="unnamed-types-1c542776d8594f7e889ad3f2c5b93f45.html">Unnamed types</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">78</span><a href="singleton-f05fc49ec44c4e93b1f0a05de793c5bd.html">Singleton</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">79</span><a href="iso-c-standard-6770e597215e480bb658f449f175ed3c.html">ISO C++ Standard</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">80</span><a href="user-defined-literals-d3696e4f87894401af6c2f073d356228.html">User-defined literals</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">81</span><b>Type erasure</b></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">82</span><a href="memory-management-1e5df2e7ee0b4037ab6215139a784f28.html">Memory management</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">83</span><a href="explicit-type-conversions-10c1e1febf0e4f71b1f2173539570a03.html">Explicit type conversions</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">84</span><a href="rtti-bd2b6b7e15fe45939be0b9cb97312af0.html">RTTI</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">85</span><a href="standard-library-algorithms-106e396c5cd14e4ba70c30ba85edca56.html">Standard library algorithms</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">86</span><a href="expression-templates-9a0f90cc690546608751556567fcd897.html">Expression templates</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">87</span><a href="scopes-1b4aabcd82e1426eb2cd5f1a6cfa8e60.html">Scopes</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">88</span><a href="atomic-types-e6a35ae0352c42a09c74633d5c76667f.html">Atomic types</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">89</span><a href="static-assert-e2db693607274a61bd9e8712c9355a28.html">static assert</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">90</span><a href="constexpr-02d273f339374a5b86affbaa7082fc98.html">constexpr</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">91</span><a href="date-and-time-with-stdchrono-5eb58f1dda3c4ebeaff3c98a60cca1a7.html">Date and time with std::chrono</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">92</span><a href="trailing-return-type-289db93906304d398987cd9042ba485d.html">Trailing return type</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">93</span><a href="function-template-overloading-5b32901d2e274970ba74be06a103aa30.html">Function template overloading</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">94</span><a href="common-compile-linker-errors-4f03abce5ffe4575960152e18b342ca2.html">Common compile linker errors</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">95</span><a href="design-patterns-4a73809215a042a98178c62e1f86c80c.html">Design patterns</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">96</span><a href="optimizations-f6be37eab1ea4d12902e1e55a74f3c28.html">Optimizations</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">97</span><a href="compiling-and-building-66d100a732a044799f6257e81c004eb6.html">Compiling and building</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">98</span><a href="type-traits-b7131d5c86024af382a77c00e59ad384.html">Type traits</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">99</span><a href="one-definition-rule-2d35c52b534843d8baf3741d0b68c7ff.html">One definition rule</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">100</span><a href="unspecified-behavio-8f46fba9ba8b4eafbb5f2370fa61981b.html">Unspecified behavio</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">101</span><a href="argument-dependent-name-lookup-3b6d22157c304151b9f17d1dc6e9d0de.html">Argument dependent name lookup</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">102</span><a href="attributes-b41d10e97c12482ea1ff612580407bc1.html">Attributes</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">103</span><a href="internationalization-5080976c532d492c97359abf7dc903ae.html">Internationalization</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">104</span><a href="profiling-a0e8b380dc714c5e95645a6a96d413b0.html">Profiling</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">105</span><a href="return-type-covariance-c70aafee98194bd79b3769e9f016666b.html">Return type covariance</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">106</span><a href="non-static-member-functions-2f06e16467454c46940292f51f9f9266.html">Non-static member functions</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">107</span><a href="recursion-b2086806a25948afadcb172245e66aa0.html">Recursion</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">108</span><a href="callable-objects-0dfb5c8cd986453697a3b3f543cfd7fa.html">Callable objects</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">109</span><a href="constant-class-member-functions-14d06bc1b1124b2fa0a367a8dd9c958c.html">Constant class member functions</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">110</span><a href="c-vs.-c-11-vs-c-17-4f68e8c3ce07490aad1e1605c992a0ab.html">C++ vs. C++ 11 vs C++ 17</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">111</span><a href="inline-functions-f20236900f94491aac9b9c913f18d32c.html">Inline functions</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">112</span><a href="client-server-examples-48c65d67f77e4b0bb90a83ab75bd68a9.html">Client server examples</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">113</span><a href="header-files-fc7b0093a3864cfb9e24ebd1f41fa3fa.html">Header files</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">114</span><a href="const-correctness-1e648ce1cc7e4997bf6e9a33d2ac504d.html">Const correctness</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">115</span><a href="refactoring-techniques-d5db2d0f24c44bf6a1d3fc170bfb1b75.html">Refactoring techniques</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">116</span><a href="parameter-packs-b4ae7d5c1d5646c7a0d99af16a5bad5f.html">Parameter packs</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">117</span><a href="iteration-13e1fda6ad154061a10ed4a621970eb7.html">Iteration</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">118</span><a href="type-deduction-29483c03d3f3426cbd916dba06c1c86f.html">type deduction</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">119</span><a href="c-11-memory-model-5731e795bc6e4f67a20fe1ea328ebb4e.html">C++ 11 memory model</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">120</span><a href="build-systems-ffc91cd7ce2e43bd83f9dd500633c0a2.html">Build systems</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">121</span><a href="concurrency-with-openmp-50856007ed7d41fb8551374ecae3e24b.html">Concurrency with OpenMP</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">122</span><a href="type-inference-69b8fd2cca444dcb84cc49ed820592d4.html">Type inference</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">123</span><a href="resource-management-cbbee582eb1d4f69a297e10ba2cd83ab.html">Resource management</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">124</span><a href="storage-class-specifiers-e3f3218764e14609b29474d479b50a70.html">Storage class specifiers</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">125</span><a href="alignment-dadb2eed69394a7d9afa46a0514a66be.html">Alignment</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">126</span><a href="inline-variables-7933074e41234c04823524ded3b719ed.html">Inline variables</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">127</span><a href="linkage-specifications-3e5157194b1e4dc7995545485e25e7d3.html">Linkage specifications</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">128</span><a href="curiusly-recurring-template-pattern-c793f95dc3c94e23a753d7b7871c3bbf.html">Curiusly recurring template pattern</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">129</span><a href="using-declaration-f0479f5d620b453ab4764c9e9418b846.html">Using declaration</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">130</span><a href="typedef-and-type-aliases-020f0e910de04617bb97e4863949153d.html">Typedef and type aliases</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">131</span><a href="layout-of-object-types-6dc44543880c4829bd86818b80f5aac6.html">Layout of object types</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">132</span><a href="c-incompatibilities-0cb787c779fb4e4ca8f2c95bfa483953.html">C incompatibilities</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">133</span><a href="optimization-4e04587c419b4bb3bcb4efe6a43e35e9.html">Optimization</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">134</span><a href="semaphore-46b28c54a7e142869bdc69ae87c3bad3.html">Semaphore</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">135</span><a href="thread-synchronization-5e61d3515c674222b553e5a42137412d.html">Thread synchronization</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">136</span><a href="debugging-e819fb9f77e3490d9b3b288189045e39.html">Debugging</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">137</span><a href="futures-and-promises-b1cbbef766d349c3aafff598af5cdf47.html">Futures and promises</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">138</span><a href="more-undefined-behaviors-05715f550a2a4c158aa1b8c1e8aa98a4.html">More undefined behaviors</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">139</span><a href="mutexes-f0a4483b95d94c828e4115c96d864674.html">Mutexes</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">140</span><a href="recursive-mutex-2dfdecd0c2284dc2941d0a4e53390d1c.html">Recursive mutex</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">141</span><a href="unit-testing-2172f3636ba34c7db75a95189cc14546.html">Unit testing</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">142</span><a href="decltype-6f1bdf3d14744baa98bdf39758d46389.html">decltype</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">143</span><a href="digit-separators-03d0218f3acf4c0989026b09a4f35be4.html">Digit separators</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">144</span><a href="c-containers-5291840b1ac044739bc3691467a51c05.html">C++ Containers</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">145</span><a href="arithmetic-meta-programming-83d53c9bbf1442a28fb8238a2fcb905a.html">Arithmetic meta-programming</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">146</span><a href="contributors-1070849124c348f4b554d2665157037f.html">Contributors</a></div></div></div></div>
    </div>
  </div></body>
</html>