<!doctype html>
<html lang="en">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="../../assets/main.css" rel="stylesheet">
</head>
<body class="page">
<header class="page__header">
    <div class="page__header__left">
        <a id="link-home" href="../../index.html">
            &nbsp;Essential Books</a>
    </div>
</header>
<div class="content">
    <div class="article">
      

<div style="display: flex; justify-content: space-between">
  <h1 class="title">Introduction To Prims Algorithm</h1>
  <a class="edit-link" style="font-size: 80%" href="https://notion.so/b44284356873415d9c1ed463668d107b" rel="nofollow" target="_blank">suggest change</a>
</div>


      
<p>Let’s say we have <strong>8</strong> houses. We want to setup telephone lines between these houses. The edge between the houses represent the cost of setting line between two houses.
</p>
<img class="img" src="img/c27aed862c3b1580016ef5dc5c17246bc48a6e34.png.html">
<p>Our task is to set up lines in such a way that all the houses are connected and the cost of setting up the whole connection is minimum. Now how do we find that out? We can use <strong>Prim’s Algorithm</strong>.
</p>
<p><a href="https://en.wikipedia.org/wiki/Prim's_algorithm">Prim’s Algorithm</a> is a greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. This means it finds a subset of the edges that forms a tree that includes every node, where the total weight of all the edges in the tree are minimized. The algorithm was developed in 1930 by Czech mathematician <a href="https://en.wikipedia.org/wiki/Vojt%C4%9Bch_Jarn%C3%ADk">Vojtěch Jarník</a> and later rediscovered and republished by computer scientist <a href="https://en.wikipedia.org/wiki/Robert_C._Prim">Robert Clay Prim</a> in 1957 and <a href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra">Edsger Wybe Dijkstra</a> in 1959. It is also known as <strong>DJP algorithm</strong>, <strong>Jarnik’s algorithm</strong>, <strong>Prim-Jarnik algorithm</strong> or <strong>Prim-Dijsktra algorithm</strong>.
</p>
<p>Now let’s look at the technical terms first. If we create a graph, <strong>S</strong> using some nodes and edges of an undirected graph <strong>G</strong>, then <strong>S</strong> is called a <strong>subgraph</strong> of the graph <strong>G</strong>. Now <strong>S</strong> will be called a <strong>Spanning Tree</strong> if and only if:
</p>
  <ul id="f9609d3a-b5c7-48d1-84c8-6065d3d3014f" class="bulleted-list">
    <li>It contains all the nodes of <strong>G</strong>.
    </li>
    <li>It is a tree, that means there is no cycle and all the nodes are connected.
    </li>
    <li>There are <strong>(n-1)</strong> edges in the tree, where <strong>n</strong> is the number of nodes in <strong>G</strong>.
    </li>
  </ul>
<p>There can be many <strong>Spanning Tree</strong>‘s of a graph. The <strong>Minimum Spanning Tree</strong> of a weighted undirected graph is a tree, such that sum of the weight of the edges is minimum. Now we’ll use <strong>Prim’s algorithm</strong> to find out the minimum spanning tree, that is how to set up the telephone lines in our example graph in such way that the cost of set up is minimum.
</p>
<p>At first we’ll select a <strong>source</strong> node. Let’s say, <strong>node-1</strong> is our <strong>source</strong>. Now we’ll add the edge from <strong>node-1</strong> that has the minimum cost to our subgraph. Here we mark the edges that are in the subgraph using the color <strong>blue</strong>. Here <strong>1-5</strong> is our desired edge.
</p>
<img class="img" src="img/931b1ba51013f20b518e28e4fbb7aefa4925f92f.png.html">
<p>Now we consider all the edges from <strong>node-1</strong> and <strong>node-5</strong> and take the minimum. Since <strong>1-5</strong> is already marked, we take <strong>1-2</strong>.
</p>
<img class="img" src="img/12b6a62bc946d61b69579dbe3a84c92ceb60cfde.png.html">
<p>This time, we consider <strong>node-1</strong>, <strong>node-2</strong> and <strong>node-5</strong> and take the minimum edge which is <strong>5-4</strong>.
</p>
<img class="img" src="img/8c8fd0dccbab1e8db6b6d55ac2b3e265ea886ee8.png.html">
<p>The next step is important. From <strong>node-1</strong>, <strong>node-2</strong>, <strong>node-5</strong> and <strong>node-4</strong>, the minimum edge is <strong>2-4</strong>. But if we select that one, it’ll create a cycle in our subgraph. This is because <strong>node-2</strong> and <strong>node-4</strong> are already in our subgraph. So taking edge <strong>2-4</strong> doesn’t benefit us. <em>We’ll select the edges in such way that it adds a new node in our subgraph</em>. So we select edge <strong>4-8</strong>.
</p>
<img class="img" src="img/3e7bd5afab1f1605c046730b3384412ca34e5c59.png.html">
<p>If we continue this way, we’ll select edge <strong>8-6</strong>, <strong>6-7</strong> and <strong>4-3</strong>. Our subgraph will look like:
</p>
<img class="img" src="img/511f8cf82650dfdbed78c862efb3e27db4e68acb.png.html">
<p>This is our desired subgraph, that’ll give us the minimum spanning tree. If we remove the edges that we didn’t select, we’ll get:
</p>
<img class="img" src="img/dfcca362aa0ef5792c5649c355b7afbad86fe238.png.html">
<p>This is our <strong>minimum spanning tree</strong> (MST). So the cost of setting up the telephone connections is: <strong>4</strong> + <strong>2</strong> + <strong>5</strong> + <strong>11</strong> + <strong>9</strong> + <strong>2</strong> + <strong>1</strong> = <strong>34</strong>. And the set of houses and their connections are shown in the graph. There can be multiple <strong>MST</strong> of a graph. It depends on the <strong>source</strong> node we choose.
</p>
<p>The pseudo-code of the algorithm is given below:
</p>

<div class="code-box lang-Plain Text">
	<div>
	<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl">Procedure PrimsMST(Graph):     // here Graph is a non-empty connected weighted graph
</span></span><span class="line"><span class="cl">Vnew[] = {x}                   // New subgraph Vnew with source node x
</span></span><span class="line"><span class="cl">Enew[] = {}
</span></span><span class="line"><span class="cl">while Vnew is not equal to V
</span></span><span class="line"><span class="cl">    u -&gt; a node from Vnew
</span></span><span class="line"><span class="cl">    v -&gt; a node that is not in Vnew such that edge u-v has the minimum cost
</span></span><span class="line"><span class="cl">                               // if two nodes have same weight, pick any of them
</span></span><span class="line"><span class="cl">    add v to Vnew
</span></span><span class="line"><span class="cl">    add edge (u, v) to Enew
</span></span><span class="line"><span class="cl">end while
</span></span><span class="line"><span class="cl">Return Vnew and Enew</span></span></code></pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>
<p><strong>Complexity:</strong>
</p>
<p>Time complexity of the above naive approach is <strong>O(V²)</strong>. It uses adjacency matrix. We can reduce the complexity using priority queue. When we add a new node to <strong>Vnew</strong>, we can add its adjacent edges in the priority queue. Then pop the minimum weighted edge from it. Then the complexity will be: <strong>O(ElogE)</strong>, where <strong>E</strong> is the number of edges. Again a Binary Heap can be constructed to reduce the complexity to <strong>O(ElogV)</strong>.
</p>
<p>The pseudo-code using Priority Queue is given below:
</p>

<div class="code-box lang-Plain Text">
	<div>
	<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl">Procedure MSTPrim(Graph, source):
</span></span><span class="line"><span class="cl">for each u in V
</span></span><span class="line"><span class="cl">    key[u] := inf
</span></span><span class="line"><span class="cl">    parent[u] := NULL
</span></span><span class="line"><span class="cl">end for
</span></span><span class="line"><span class="cl">key[source] := 0
</span></span><span class="line"><span class="cl">Q = Priority_Queue()
</span></span><span class="line"><span class="cl">Q = V
</span></span><span class="line"><span class="cl">while Q is not empty
</span></span><span class="line"><span class="cl">    u -&gt; Q.pop
</span></span><span class="line"><span class="cl">    for each v adjacent to i
</span></span><span class="line"><span class="cl">        if v belongs to Q and Edge(u,v) &lt; key[v]    // here Edge(u, v) represents
</span></span><span class="line"><span class="cl">                                                    // cost of edge(u, v)
</span></span><span class="line"><span class="cl">            parent[v] := u
</span></span><span class="line"><span class="cl">            key[v] := Edge(u, v)
</span></span><span class="line"><span class="cl">        end if
</span></span><span class="line"><span class="cl">    end for
</span></span><span class="line"><span class="cl">end while</span></span></code></pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>
<p>Here <strong>key[]</strong> stores the minimum cost of traversing <strong>node-v</strong>. <strong>parent[]</strong> is used to store the parent node. It is useful for traversing and printing the tree.
</p>
<p>Below is a simple program in Java:
</p>

<div class="code-box lang-Plain Text">
	<div>
	<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl">import java.util.*;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public class Graph
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">   private static int infinite = 9999999;
</span></span><span class="line"><span class="cl">   int[][]  LinkCost;
</span></span><span class="line"><span class="cl">   int      NNodes;
</span></span><span class="line"><span class="cl">   Graph(int[][] mat)
</span></span><span class="line"><span class="cl">   {
</span></span><span class="line"><span class="cl">      int i, j;
</span></span><span class="line"><span class="cl">      NNodes = mat.length;
</span></span><span class="line"><span class="cl">      LinkCost = new int[NNodes][NNodes];
</span></span><span class="line"><span class="cl">      for ( i=0; i &lt; NNodes; i++)
</span></span><span class="line"><span class="cl">      {
</span></span><span class="line"><span class="cl">         for ( j=0; j &lt; NNodes; j++)
</span></span><span class="line"><span class="cl">         {
</span></span><span class="line"><span class="cl">            LinkCost[i][j] = mat[i][j];
</span></span><span class="line"><span class="cl">            if ( LinkCost[i][j] == 0 )
</span></span><span class="line"><span class="cl">               LinkCost[i][j] = infinite;
</span></span><span class="line"><span class="cl">         }
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      for ( i=0; i &lt; NNodes; i++)
</span></span><span class="line"><span class="cl">      {
</span></span><span class="line"><span class="cl">         for ( j=0; j &lt; NNodes; j++)
</span></span><span class="line"><span class="cl">            if ( LinkCost[i][j] &lt; infinite )
</span></span><span class="line"><span class="cl">               System.out.print( " " + LinkCost[i][j] + " " );
</span></span><span class="line"><span class="cl">            else
</span></span><span class="line"><span class="cl">               System.out.print(" * " );
</span></span><span class="line"><span class="cl">         System.out.println();
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">   public int unReached(boolean[] r)
</span></span><span class="line"><span class="cl">   {
</span></span><span class="line"><span class="cl">      boolean done = true;
</span></span><span class="line"><span class="cl">      for ( int i = 0; i &lt; r.length; i++ )
</span></span><span class="line"><span class="cl">         if ( r[i] == false )
</span></span><span class="line"><span class="cl">            return i;
</span></span><span class="line"><span class="cl">      return -1;
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">   public void Prim( )
</span></span><span class="line"><span class="cl">   {
</span></span><span class="line"><span class="cl">      int i, j, k, x, y;
</span></span><span class="line"><span class="cl">      boolean[] Reached = new boolean[NNodes];
</span></span><span class="line"><span class="cl">      int[] predNode = new int[NNodes];
</span></span><span class="line"><span class="cl">      Reached[0] = true;
</span></span><span class="line"><span class="cl">      for ( k = 1; k &lt; NNodes; k++ )
</span></span><span class="line"><span class="cl">      {
</span></span><span class="line"><span class="cl">         Reached[k] = false;
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      predNode[0] = 0;
</span></span><span class="line"><span class="cl">      printReachSet( Reached );
</span></span><span class="line"><span class="cl">      for (k = 1; k &lt; NNodes; k++)
</span></span><span class="line"><span class="cl">      {
</span></span><span class="line"><span class="cl">         x = y = 0;
</span></span><span class="line"><span class="cl">         for ( i = 0; i &lt; NNodes; i++ )
</span></span><span class="line"><span class="cl">            for ( j = 0; j &lt; NNodes; j++ )
</span></span><span class="line"><span class="cl">            {
</span></span><span class="line"><span class="cl">                if ( Reached[i] &amp;&amp; !Reached[j] &amp;&amp;
</span></span><span class="line"><span class="cl">                     LinkCost[i][j] &lt; LinkCost[x][y] )
</span></span><span class="line"><span class="cl">                {
</span></span><span class="line"><span class="cl">                   x = i;
</span></span><span class="line"><span class="cl">                   y = j;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">         System.out.println("Min cost edge: (" +
</span></span><span class="line"><span class="cl">                                + x + "," +
</span></span><span class="line"><span class="cl">                                + y + ")" +
</span></span><span class="line"><span class="cl">                                "cost = " + LinkCost[x][y]);
</span></span><span class="line"><span class="cl">         predNode[y] = x;
</span></span><span class="line"><span class="cl">         Reached[y] = true;
</span></span><span class="line"><span class="cl">         printReachSet( Reached );
</span></span><span class="line"><span class="cl">         System.out.println();
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">      int[] a= predNode;
</span></span><span class="line"><span class="cl">   for ( i = 0; i &lt; NNodes; i++ )
</span></span><span class="line"><span class="cl">          System.out.println( a[i] + " --&gt; " + i );
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">   void printReachSet(boolean[] Reached )
</span></span><span class="line"><span class="cl">   {
</span></span><span class="line"><span class="cl">      System.out.print("ReachSet = ");
</span></span><span class="line"><span class="cl">      for (int i = 0; i &lt; Reached.length; i++ )
</span></span><span class="line"><span class="cl">         if ( Reached[i] )
</span></span><span class="line"><span class="cl">           System.out.print( i + " ");
</span></span><span class="line"><span class="cl">      //System.out.println();
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl"> public static void main(String[] args)
</span></span><span class="line"><span class="cl">   {
</span></span><span class="line"><span class="cl">      int[][] conn = {{0,3,0,2,0,0,0,0,4},  // 0
</span></span><span class="line"><span class="cl">                      {3,0,0,0,0,0,0,4,0},  // 1
</span></span><span class="line"><span class="cl">                      {0,0,0,6,0,1,0,2,0},  // 2
</span></span><span class="line"><span class="cl">                      {2,0,6,0,1,0,0,0,0},  // 3
</span></span><span class="line"><span class="cl">                      {0,0,0,1,0,0,0,0,8},  // 4
</span></span><span class="line"><span class="cl">                      {0,0,1,0,0,0,8,0,0},  // 5
</span></span><span class="line"><span class="cl">                      {0,0,0,0,0,8,0,0,0},  // 6
</span></span><span class="line"><span class="cl">                      {0,4,2,0,0,0,0,0,0},  // 7
</span></span><span class="line"><span class="cl">                      {4,0,0,0,8,0,0,0,0}   // 8
</span></span><span class="line"><span class="cl">                     };
</span></span><span class="line"><span class="cl">      Graph G = new Graph(conn);
</span></span><span class="line"><span class="cl">      G.Prim();
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">}</span></span></code></pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>
<p>Compile the above code using <code>javac Graph.java</code>
</p>
<p>Output:
</p>

<div class="code-box lang-Plain Text">
	<div>
	<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl">$ java Graph
</span></span><span class="line"><span class="cl"> *  3  *  2  *  *  *  *  4
</span></span><span class="line"><span class="cl"> 3  *  *  *  *  *  *  4  *
</span></span><span class="line"><span class="cl"> *  *  *  6  *  1  *  2  *
</span></span><span class="line"><span class="cl"> 2  *  6  *  1  *  *  *  *
</span></span><span class="line"><span class="cl"> *  *  *  1  *  *  *  *  8
</span></span><span class="line"><span class="cl"> *  *  1  *  *  *  8  *  *
</span></span><span class="line"><span class="cl"> *  *  *  *  *  8  *  *  *
</span></span><span class="line"><span class="cl"> *  4  2  *  *  *  *  *  *
</span></span><span class="line"><span class="cl"> 4  *  *  *  8  *  *  *  *
</span></span><span class="line"><span class="cl">ReachSet = 0 Min cost edge: (0,3)cost = 2
</span></span><span class="line"><span class="cl">ReachSet = 0 3
</span></span><span class="line"><span class="cl">Min cost edge: (3,4)cost = 1
</span></span><span class="line"><span class="cl">ReachSet = 0 3 4
</span></span><span class="line"><span class="cl">Min cost edge: (0,1)cost = 3
</span></span><span class="line"><span class="cl">ReachSet = 0 1 3 4
</span></span><span class="line"><span class="cl">Min cost edge: (0,8)cost = 4
</span></span><span class="line"><span class="cl">ReachSet = 0 1 3 4 8
</span></span><span class="line"><span class="cl">Min cost edge: (1,7)cost = 4
</span></span><span class="line"><span class="cl">ReachSet = 0 1 3 4 7 8
</span></span><span class="line"><span class="cl">Min cost edge: (7,2)cost = 2
</span></span><span class="line"><span class="cl">ReachSet = 0 1 2 3 4 7 8
</span></span><span class="line"><span class="cl">Min cost edge: (2,5)cost = 1
</span></span><span class="line"><span class="cl">ReachSet = 0 1 2 3 4 5 7 8
</span></span><span class="line"><span class="cl">Min cost edge: (5,6)cost = 8
</span></span><span class="line"><span class="cl">ReachSet = 0 1 2 3 4 5 6 7 8
</span></span><span class="line"><span class="cl">0 --&gt; 0
</span></span><span class="line"><span class="cl">0 --&gt; 1
</span></span><span class="line"><span class="cl">7 --&gt; 2
</span></span><span class="line"><span class="cl">0 --&gt; 3
</span></span><span class="line"><span class="cl">3 --&gt; 4
</span></span><span class="line"><span class="cl">2 --&gt; 5
</span></span><span class="line"><span class="cl">5 --&gt; 6
</span></span><span class="line"><span class="cl">1 --&gt; 7
</span></span><span class="line"><span class="cl">0 --&gt; 8</span></span></code></pre>
	</div>
	<div class="code-box-nav">
		
	</div>
</div>

      <div class="forum-link">
  Found a mistake? Have a question or improvement idea?
  <a href="introduction-to-prims-algorithm-b44284356873415d9c1ed463668d107b.html#" onclick="showContact(); return false;">Let me know</a>.
</div>

      <form id="contact-form" action="https://formsubmit.co/kkowalczyk@gmail.com" method="POST">
  <p>
    </p><div class="contact-light">Feedback about page:</div>
    <input type="text" name="page-url" id="contact-page-url" readonly>
  

  <p>
    </p><div class="contact-light">Feedback:</div>
    <textarea name="message" id="msg-for-chris"></textarea>
    <div class="contact-light">Optional: your email if you want me to get back to you: </div>
    <input type="email" name="email">
    <input type="hidden" name="_template" value="box">
    <input type="text" name="_honey" class="noshow">
  

  <p>
    <button type="submit" class="contact-btn">
      Send Feedback
    </button>

    <button class="contact-btn" style="float: right;" onclick="hideContact(); return false;">
      Cancel
    </button>
  </p>
</form>


      <hr class="article-bottom-sep">
    </div>

    <div id="page-toc"><div class="article chapter-toc svelte-1t851gm"><div class="mtoc-0 svelte-1t851gm"><b>Prims Algorithm:</b></div><div class="mtoc-1 svelte-1t851gm"><span class="no svelte-1ib47n1">*</span><a href="prims-algorithm-4f56fc079aa74e02adc425b6a5ca1811.html">Prims Algorithm</a></div><div class="mtoc-1 svelte-1t851gm"><span class="no svelte-1ib47n1">*</span><b>Introduction To Prims Algorithm</b></div></div></div>

    <div id="chapter-toc-wrapper">
      <hr>
      <div class="hdr">Table Of Contents</div>
      <div id="book-toc"><div class="article toc svelte-1ib47n1"><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">0</span><a href="getting-started-91fee7b5614e44ac9c692c43b78c7706.html">Getting started</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">1</span><a href="sorting-1b2f4c664ea64d7ba266531792730534.html">Sorting</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">2</span><a href="bubble-sort-6eb693f8f70b45c9a6db644dea3bc144.html">Bubble sort</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">3</span><a href="algorithm-complexity-ee1a453958894a51bc451ed4ce501170.html">Algorithm complexity</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">4</span><a href="graphs-8ae5c9b5b80d4e27930b0dbbf5b2a075.html">Graphs</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">5</span><a href="dynamic-programming-0483f45cfa31493ebd1bb9e924123210.html">Dynamic programming</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">6</span><a href="kruskals-algorithm-e737c451edb24ee18b504891f751f559.html">Kruskals algorithm</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">7</span><a href="greedy-algorithms-fb292c5c1e2c4d169d29fce0aff04b2b.html">Greedy algorithms</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">8</span><a href="searching-c8277fc46841459e81f4c90a99fd83fa.html">Searching</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">9</span><a href="big-o-notation-adfec1cf49414483b98d9550de7e3916.html">Big O notation</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">10</span><a href="bellman-for-algorithm-2bfd570fdc074daab3b2a794ef12f08e.html">Bellman-For Algorithm</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">11</span><a href="merge-sort-a034d8c3224b46dcbc26d44b569e39e0.html">Merge Sort</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">12</span><a href="binary-search-trees-8c1be63050c94162b355a5d6917f9e65.html">Binary Search Trees</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">13</span><a href="trees-56228e72edf04f14b6c71d113093b22a.html">Trees</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">14</span><a href="insertion-sort-2885c26f551147a5900d5d725326f99d.html">Insertion Sort</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">15</span><a href="hash-functions-e800516eb244400089c70041f1acd148.html">Hash Functions</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">16</span><a href="traveling-salesman-7c62ae2de3344dc4a641184b79672747.html">Traveling Salesman</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">17</span><a href="substring-search-ec9d0bba8ded4256866e28adfde6676e.html">Substring Search</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">18</span><a href="dijkstras-algorithm-f00ac53f26f54356bd05744ca9c233b1.html">Dijkstras Algorithm</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">19</span><a href="floyd-warshall-algorithm-07b6aee186e24b06953393f2f24dd419.html">Floyd-Warshall Algorithm</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">20</span><a href="breadth-first-search-3104f50ab7e241fe97d7f6e02201ccb8.html">Breadth-First Search</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">21</span><a href="bucket-sort-aed1f400b221406780e62fda841c33f0.html">Bucket Sort</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">22</span><a href="quicksort-a747cf00d05a41329b344cea62968a38.html">Quicksort</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">23</span><a href="depth-first-search-0abdd157bda84285b8a75aa4dd7e132b.html">Depth-First Search</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">24</span><a href="knapsack-problem-e79c088d5ede4b22b5dc16273a672796.html">Knapsack Problem</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">25</span><a href="counting-sort-721fb53cf2404ce6aaaa9f4be08c3460.html">Counting Sort</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">26</span><a href="cycle-sort-38ae0e5d81ea45b2b7f48eb197662514.html">Cycle Sort</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">27</span><a href="heap-sort-c06d75d61a6d48da8e094d63502dedee.html">Heap Sort</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">28</span><b>Prims Algorithm</b></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">29</span><a href="matrix-exponentiation-db10fdd2ea0b4236ae1494781b2f7586.html">Matrix Exponentiation</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">30</span><a href="pigeonhole-sort-9bd5a67d2c304b51a6b7b9eb3583b888.html">Pigeonhole Sort</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">31</span><a href="radix-sort-29a89f00863f40848ec5db4c455fc788.html">Radix Sort</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">32</span><a href="equation-solving-2734ccd8075a412f8976e67dfd9416da.html">Equation Solving</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">33</span><a href="odd-even-sort-a5ee928035d04aac89a2decbe44f483e.html">Odd-Even Sort</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">34</span><a href="pseudocode-790101e3fd8c47e3bcc454b18dc2fd9a.html">Pseudocode</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">35</span><a href="catalan-number-algorithm-aa2725ade1d140edab4f0042fe8e222f.html">Catalan Number Algorithm</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">36</span><a href="integer-partition-algorithm-7261d2a39d9d43cb9e3a4b432a018d9e.html">Integer Partition Algorithm</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">37</span><a href="a-pathfinding-7e7202cf172e479eb1d42842091d8b3e.html">A* Pathfinding</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">38</span><a href="shell-sort-ee3641188538481787be3e716db337cb.html">Shell Sort</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">39</span><a href="selection-sort-4ee11beba38d47e382277414b7e09239.html">Selection Sort</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">40</span><a href="pancake-sort-f82e52a5bc1541068c592d323c6aa2f1.html">Pancake Sort</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">41</span><a href="longest-common-subsequence-547abd24965c44ceb5f0e452aeea3821.html">Longest Common Subsequence</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">42</span><a href="longest-increasing-subsequence-d33782abd4ee4ba9938d2922e11247be.html">Longest Increasing Subsequence</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">43</span><a href="maximum-path-sum-algorithm-0c0e3472dac8416a833b40ef5e725f54.html">Maximum Path Sum Algorithm</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">44</span><a href="maxiumum-subarray-algorithm-c677c53060364f08810c5e2b963b6ded.html">Maxiumum Subarray Algorithm</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">45</span><a href="dynamic-time-warping-d1c46e3a31cb41e0acf1907b405548a3.html">Dynamic Time Warping</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">46</span><a href="pascal-triangle-24e66a7fc2cb4c77b4245e08b603ee59.html">Pascal Triangle</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">47</span><a href="line-drawing-15b863c228b54b319379ff8091b43c28.html">Line drawing</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">48</span><a href="shortest-common-supersequence-5eb1332d741d47f8ad4cda01f28ef2ed.html">Shortest Common Supersequence</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">49</span><a href="sliding-window-algorithm-88259ac245264ea5b9e9d03f7dd06c8e.html">Sliding Window Algorithm</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">50</span><a href="application-of-greedy-techniqe-0652a44d8a6347b5b7cfaf85d0c3655a.html">Application of greedy techniqe</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">51</span><a href="online-algorithms-61f46cc6d7e04aebae8a47f4eb52c2bc.html">Online algorithms</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">52</span><a href="fast-fourier-transform-a3747844afb94883bbb2bea5662e919d.html">Fast Fourier Transform</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">53</span><a href="a-path-finding-algorithm-e567adff577f4fa6849a1a112f689048.html">A* Path-finding Algorithm</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">54</span><a href="check-if-tree-is-bst-c96af0bea3eb4385a6740f83049a23fd.html">Check if tree is BST</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">55</span><a href="binary-tree-traversal-1357e1664a6143aba4f0d9cbd7ba53de.html">Binary tree traversal</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">56</span><a href="lowest-common-ancestor-of-a-binary-tree-e7f8518091d140758feb5b5f495422a9.html">Lowest common ancestor of a binary tree</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">57</span><a href="graph-traversal-2a8a00f4a54041b487f7465c42e6a071.html">Graph Traversal</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">58</span><a href="minimum-vertex-cover-f11f3084c84d4f6e91d08c55df0d8c59.html">Minimum Vertex Cover</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">59</span><a href="multi-threaded-algorithms-491070bf06ff4de8bf7f3e121c11c49f.html">Multi-threaded Algorithms</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">60</span><a href="print-mxn-matrix-in-square-wise-2a95e83b1c1e40d2b8e08917aa02703e.html">Print MxN matrix in square wise</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">61</span><a href="check-two-strings-are-anagrams-a30ef1622edd4b1290d725d5049ed098.html">Check two strings are anagrams</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">62</span><a href="edit-distance-dynamic-algorithm-eaba21c76ac1482fbdc29410e7140b3d.html">Edit Distance Dynamic Algorithm</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">63</span><a href="applications-of-dynamic-programming-1f7d7534a5224df6a49544f1c3e4179d.html">Applications of Dynamic Programming</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">64</span><a href="knuth-moriss-pratt-924ef53cfe524d0f82331cbc0f7eb8f7.html">Knuth Moriss Pratt</a></div></div><div class="toc-item"><div class="chapters-toc-item"><span class="no svelte-1ib47n1">65</span><a href="contributors-d9ba24fd508b4ddc9d8c15467083ba43.html">Contributors</a></div></div></div></div>
    </div>
  </div></body>
</html>